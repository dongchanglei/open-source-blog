---
desc: 由 genpost (https://github.com/hidevopsio/genpost) 代码生成器生成
title: Tomcat
date: 2020-07-24T09:47:58+08:00
author: 箜箜如也
draft: false
tags:
- Tomcat
---

## WEB技术
1. 早期的web应用主要用于浏览新闻等静态页面，用户通过HTTP协议请求服务器上的**静态页面**，服务器上的web服务器软件接收到请求后，读取URI标示的资源，再加上消息报头发送给客户端浏览器，浏览器负责解析HTML，将结果呈现出来。
2. 随着时间发展，用户需要一些交互操作，获取一些动态结果；所以需要一些扩展机制来实现用户想要的功能；早期使用的Web服务器扩展机制是CGI（Common Gateway Interface，公共网关接口）。
3. CGI：是外部应用程序(CGI程序)与Web服务器之间的接口标准，是在CGI程序和Web服务器之间传递信息的规程；使用这种方法，用户单击某个链接或输入网址来访问CGI程序，web服务器收到请求后，运行该CGI程序，对用户请求进行处理，紧接着将处理结果并产生一个响应，该响应被返回给web服务器，web服务器对响应进行包装，以HTTP响应的方式返回给浏览器。
4. CGI程序在一定程度上解决了用户需求。不过还存在一些不足之处，如CGI程序编写困难，响应时间较长，以进程方式运行导致性能受限；个人理解，就是java应用socket技术实现网络通信，使client与server进行交互的一个缩影。

## SERVLET接口

```
浏览器发给服务端的是一个HTTP格式的请求，HTTP服务器收到这个请求后，需要调用服务端程序来处理，所谓的服务端程序就是写的Java类(对于java开发来说啊)，一般来说不同的请求需要由不同的Java类来处理。
```

**但是，HTTP服务器怎么知道要调用哪个Java类的哪个方法呢？？？？**

```
咱们继续推进，最直接的办法就是在HTTP服务器里面硬编码来判断哪个请求调用哪个类的哪个方法不就OK了吗。
```

**虽然可以解决调用问题，但这样做明显存在其他问题啊**

```
因为HTTP服务器的代码跟业务逻辑耦合在一起了，如果新加一个业务方法还要改HTTP服务器的代码，高度耦合。
```

**于是乎，面向接口编程这个解决耦合问题的法宝便出现了**

```
定义了一个接口，各种业务类都必须实现这个接口，这个接口就叫Servlet接口；我们通常把实现了Servlet接口的业务类叫作Servlet。
```

**但是情况不容乐观这里还有问题啊，对于特定的请求呢，HTTP服务器如何知道由哪个Servlet来处理呢？Servlet又该由谁初始化呢？**

```
HTTP服务器很显然不适合做这个工作，不然又跟业务代码耦合在一起了。
顺理成章Servlet容器变风光上场了！！！
```

## Servlet与Servlet容器
1. 于是1997年，sun公司推出了**Servlet技术**，作为java阵营的CGI解决方案。
2. Servlet是平台独立的Java类，编写一个Servlet，**实际上就是按照Servlet规范编写一个Java类**。Servlet被编译为平台独立的字节码，可以被动态地加载到支持Java技术的Web服务器中运行。
3. Servlet就是一个普普通通的Java类，它没有main方法，不能独立运行；这时候就需要解决服务器如何来运行这个Servlet程序。
4. 为了运行Servlet程序，Servlet容器便出现了。
5. Servlet容器的主要作用是：

    ```
    Servlet容器用来加载和管理业务类。 
    ```
    
6. Servlet容器工作模式的不同，Servlet容器有以下分类：

    1> 独立的Servlet容器 
    
        当我们使用基于Java技术的Web服务器时，Servlet容器作为构成Web服务器的一部分而存在；然而大多数的Web服务器并非基于Java语言，因此，就有了下面两种Servlet容器的工作模式。
        
    2> 进程内的Servlet容器
    
        Servlet容器由Web服务器插件和Java容器两部分实现组成。Web服务器插件在某个Web服务器内部地址空间中打开一个JVM（Java虚拟机），使得Java容器可以在此JVM中加载并运行Servlet。如有客户端调用Servlet的请求到来，插件取得对此请求的控制并将它传递（使用JNI技术）给Java容器，然后由Java容器将此请求交由Servlet进行处理。**进程内的Servlet容器对于单进程、多线程的服务器非常适合，提供了较高的运行速度，但伸缩性有所不足**。JNI 即Java native interface，是一种技术，提供了丰富的接口，可以在Java层调用native代码，也可以在native层调用Java代码，native代码一般是指C/C++程序或者其他语音。
        
    3> 进程外的Servlet容器
    
        Servlet容器运行于Web服务器之外的地址空间，它也是由Web服务器插件和Java容器两部分实现组成的。Web服务器插件和Java容器（在外部JVM中运行）使用IPC机制（通常是TCP/IP）进行通信。当一个调用Servlet的请求到达时，插件取得对此请求的控制并将其传递（使用IPC机制）给Java容器。进程外Servlet容器对客户请求的响应速度不如进程内的Servlet容器，但进程外容器具有更好的伸缩性和稳定性。IPC机制 Inter-Process Communication 多个进程间的通信机制，两个进程间进行数据交互的过程；在linux下有多种进程间通信的方法：半双工管道、命名管道、消息队列、信号、信号量、共享内存、内存映射文件，socket等等。
        
**HTTP服务器和Servlet容器完美组合，就满足了业务需求！！！**

```
建立socket连接
调用Servlet处理业务逻辑
响应数据
关闭socket连接
```

**此时，Servlet接口和Servlet容器这一整套规范变成了Servlet规范，Tomcat按照这个规范实现了Servlet容器同时增加了HTTP服务能力，轻量级的WEB服务器Tomcat随即问世了。**
    
## TOMCAT容器

Tomcat是一个免费的开放源的Servlet容器，并且具有处理HTTP请求的能力，因此称它为轻量级的WEB服务器。

**让我们看一下Tomcat工作原理图**

<img src="https://dongchanglei.top/images/tomcatyuanli.png">

**简单回顾下Servlet的使用**

```
Web应用的目录结构
| -  MyWebApp
      | -  WEB-INF/web.xml        -- 配置文件，用来配置Servlet等
      | -  WEB-INF/lib/           -- 存放Web应用所需各种JAR包
      | -  WEB-INF/classes/       -- 存放你的应用类，比如Servlet类
      | -  META-INF/              -- 目录存放工程的一些信息
```

<img src="https://dongchanglei.top/images/tomcat.png">

```
下面简单介绍一下这些目录：
/bin：存放Windows或Linux平台上启动和关闭Tomcat的脚本文件。
/conf：存放Tomcat的各种全局配置文件，其中最重要的是server.xml。
/lib：存放Tomcat以及所有Web应用都可以访问的JAR文件。
/logs：存放Tomcat执行时产生的日志文件。
/work：存放JSP编译后产生的Class文件。
/webapps：Tomcat的Web应用目录，默认情况下把Web应用放在这个目录下。
```

<img src="https://dongchanglei.top/images/tomcatlog.png">

```
catalina.***.log
主要是记录Tomcat启动过程的信息，在这个文件可以看到启动的JVM参数以及操作系统等日志信息。

catalina.out
是Tomcat的标准输出（stdout）和标准错误（stderr），这是在Tomcat的启动脚本里指定的，如果没有修改的话stdout和stderr会重定向到这里。

localhost.**.log
主要记录Web应用在初始化过程中遇到的未处理的异常，会被Tomcat捕获而输出这个日志文件。

localhost_access_log.**.txt
存放访问Tomcat的请求日志，包括IP地址以及请求的路径、时间、请求协议以及状态码等信息。

manager.***.log/host-manager.***.log
存放Tomcat自带的Manager项目的日志信息。
```
```
javac -cp ./servlet-api.jar MyServlet.java
```
<img src="https://dongchanglei.top/images/MyServletJava.png">
<img src="https://dongchanglei.top/images/MyWebApp.png">

##分析Tomcat的设计思路
**Tomcat总体架构**
```
处理Socket连接，负责网络字节流与Request和Response对象的转化。
加载和管理Servlet，以及具体处理Request请求。
```

**因此Tomcat设计了两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情。连接器负责对外交流，容器负责内部处理。**

**下面我们就先聊聊连接器（Connector）**
```
做个铺垫：
Tomcat支持的I/O模型有：
NIO：非阻塞I/O，采用Java NIO类库实现。
NIO.2：异步I/O，采用JDK 7最新的NIO.2类库实现。
APR：采用Apache可移植运行库实现，是C/C++编写的本地库。
Tomcat 支持的应用层协议有：
HTTP/1.1：这是大部分Web应用采用的访问协议。
AJP：用于和Web服务器集成（如 Apache）。
HTTP/2：HTTP2.0大幅度的提升了Web性能。
```
Tomcat为了实现支持多种I/O模型和应用层协议，一个容器可能对接多个连接器，就好比一个房间有多个门；但是单独的连接器或者容器都不能对外提供服务，需要把它们组装起来才能工作，组装后这个整体叫作**Service组件**；
Tomcat内可能有多个Service，通过在Tomcat中配置多个Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用，但是Service本身没有做什么重要的事情，只是在连接器和容器外面多包了一层，把它们组装在一起；

**此时，我们可以得出一张图**

<img src="https://dongchanglei.top/images/tomcat01.png">

```
从图上你可以看到，最顶层是Server，这里的Server指的就是一个Tomcat实例。一个Server 中有一个或者多个Service，一个Service中有多个连接器和一个容器。连接器与容器之间通过标准的ServletRequest和ServletResponse通信。
```
连接器对Servlet容器屏蔽了协议及I/O模型等的区别，在容器中获取到的都是一个标准的 ServletRequest和ServletResponse对象。

**连接器的功能进一步细化**
```
监听网络端口。
接受网络连接请求。
读取网络请求字节流。
根据具体应用层协议（HTTP/AJP）解析字节流，生成统一的Tomcat Request对象。
将Tomcat Request对象转成标准的ServletRequest。
调用Servlet容器，得到ServletResponse。
将ServletResponse转成Tomcat Response对象。
将Tomcat Response转成网络字节流。
将响应字节流写回给浏览器。
```

**如果让你设计连接器（Connector），你该如何设计，达到高内聚、低耦合的效果？？？**

```
简单阐述下这两个概念：
高内聚是指相关度比较高的功能要尽可能集中，不要分散。
低耦合是指两个相关的模块要尽可能减少依赖的部分和降低依赖的程度，不要让两个模块产生强依赖。
```

**好了，让我们看一看Tomcat是如何设计的？？**

```
有3个高内聚的功能：
网络通信。
应用层协议解析。
Tomcat Request/Response与ServletRequest/ServletResponse的转化。
```
因此Tomcat的设计者设计了3个组件来实现这3个功能，分别是**Endpoint**、**Processor**和**Adapter**。







