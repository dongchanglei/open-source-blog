---
desc: 由 genpost (https://github.com/hidevopsio/genpost) 代码生成器生成
title: Tomcat
date: 2020-07-24T09:47:58+08:00
author: 箜箜如也
draft: false
tags:
- Tomcat
---

## WEB技术
1. 早期的web应用主要用于浏览新闻等静态页面，用户通过HTTP协议请求服务器上的**静态页面**，服务器上的web服务器软件接收到请求后，读取URI标示的资源，再加上消息报头发送给客户端浏览器，浏览器负责解析HTML，将结果呈现出来。
2. 随着时间发展，用户需要一些交互操作，获取一些动态结果；所以需要一些扩展机制来实现用户想要的功能；早期使用的Web服务器扩展机制是CGI（Common Gateway Interface，公共网关接口）。
3. CGI：是外部应用程序(CGI程序)与Web服务器之间的接口标准，是在CGI程序和Web服务器之间传递信息的规程；使用这种方法，用户单击某个链接或输入网址来访问CGI程序，web服务器收到请求后，运行该CGI程序，对用户请求进行处理，紧接着将处理结果并产生一个响应，该响应被返回给web服务器，web服务器对响应进行包装，以HTTP响应的方式返回给浏览器。
4. CGI程序在一定程度上解决了用户需求。不过还存在一些不足之处，如CGI程序编写困难，响应时间较长，以进程方式运行导致性能受限；个人理解，就是java应用socket技术实现网络通信，使client与server进行交互的一个缩影。

## SERVLET接口

```
浏览器发给服务端的是一个HTTP格式的请求，HTTP服务器收到这个请求后，需要调用服务端程序来处理，所谓的服务端程序就是写的Java类(对于java开发来说啊)，一般来说不同的请求需要由不同的Java类来处理。
```

**但是，HTTP服务器怎么知道要调用哪个Java类的哪个方法呢？？？？**

```
咱们继续推进，最直接的办法就是在HTTP服务器里面硬编码来判断哪个请求调用哪个类的哪个方法不就OK了吗。
```

**虽然可以解决调用问题，但这样做明显存在其他问题啊**

```
因为HTTP服务器的代码跟业务逻辑耦合在一起了，如果新加一个业务方法还要改HTTP服务器的代码，高度耦合。
```

**于是乎，面向接口编程这个解决耦合问题的法宝便出现了**

```
定义了一个接口，各种业务类都必须实现这个接口，这个接口就叫Servlet接口；我们通常把实现了Servlet接口的业务类叫作Servlet。
```

**但是情况不容乐观这里还有问题啊，对于特定的请求呢，HTTP服务器如何知道由哪个Servlet来处理呢？Servlet又该由谁初始化呢？**

```
HTTP服务器很显然不适合做这个工作，不然又跟业务代码耦合在一起了。
顺理成章Servlet容器变风光上场了！！！
```

## Servlet与Servlet容器
1. 于是1997年，sun公司推出了**Servlet技术**，作为java阵营的CGI解决方案。
2. Servlet是平台独立的Java类，编写一个Servlet，**实际上就是按照Servlet规范编写一个Java类**。Servlet被编译为平台独立的字节码，可以被动态地加载到支持Java技术的Web服务器中运行。
3. Servlet就是一个普普通通的Java类，它没有main方法，不能独立运行；这时候就需要解决服务器如何来运行这个Servlet程序。
4. 为了运行Servlet程序，Servlet容器便出现了。
5. Servlet容器的主要作用是：

    ```
    Servlet容器用来加载和管理业务类。 
    ```
    
6. Servlet容器工作模式的不同，Servlet容器有以下分类：

    1> 独立的Servlet容器 
    
        当我们使用基于Java技术的Web服务器时，Servlet容器作为构成Web服务器的一部分而存在；然而大多数的Web服务器并非基于Java语言，因此，就有了下面两种Servlet容器的工作模式。
        
    2> 进程内的Servlet容器
    
        Servlet容器由Web服务器插件和Java容器两部分实现组成。Web服务器插件在某个Web服务器内部地址空间中打开一个JVM（Java虚拟机），使得Java容器可以在此JVM中加载并运行Servlet。如有客户端调用Servlet的请求到来，插件取得对此请求的控制并将它传递（使用JNI技术）给Java容器，然后由Java容器将此请求交由Servlet进行处理。**进程内的Servlet容器对于单进程、多线程的服务器非常适合，提供了较高的运行速度，但伸缩性有所不足**。JNI 即Java native interface，是一种技术，提供了丰富的接口，可以在Java层调用native代码，也可以在native层调用Java代码，native代码一般是指C/C++程序或者其他语音。
        
    3> 进程外的Servlet容器
    
        Servlet容器运行于Web服务器之外的地址空间，它也是由Web服务器插件和Java容器两部分实现组成的。Web服务器插件和Java容器（在外部JVM中运行）使用IPC机制（通常是TCP/IP）进行通信。当一个调用Servlet的请求到达时，插件取得对此请求的控制并将其传递（使用IPC机制）给Java容器。进程外Servlet容器对客户请求的响应速度不如进程内的Servlet容器，但进程外容器具有更好的伸缩性和稳定性。IPC机制 Inter-Process Communication 多个进程间的通信机制，两个进程间进行数据交互的过程；在linux下有多种进程间通信的方法：半双工管道、命名管道、消息队列、信号、信号量、共享内存、内存映射文件，socket等等。
        
**HTTP服务器和Servlet容器完美组合，就满足了业务需求！！！**

```
建立socket连接
调用Servlet处理业务逻辑
响应数据
关闭socket连接
```

**此时，Servlet接口和Servlet容器这一整套规范变成了Servlet规范，Tomcat按照这个规范实现了Servlet容器同时增加了HTTP服务能力，轻量级的WEB服务器Tomcat随即问世了。**
    
## TOMCAT容器

Tomcat是一个免费的开放源的Servlet容器，并且具有处理HTTP请求的能力，因此称它为轻量级的WEB服务器。

**让我们看一下Tomcat工作原理图**

<img src="https://dongchanglei.top/images/tomcatyuanli.png">

**简单回顾下Servlet的使用**

```
Web应用的目录结构
| -  MyWebApp
      | -  WEB-INF/web.xml        -- 配置文件，用来配置Servlet等
      | -  WEB-INF/lib/           -- 存放Web应用所需各种JAR包
      | -  WEB-INF/classes/       -- 存放你的应用类，比如Servlet类
      | -  META-INF/              -- 目录存放工程的一些信息
```

<img src="https://dongchanglei.top/images/tomcat.png">

```
下面简单介绍一下这些目录：
/bin：存放Windows或Linux平台上启动和关闭Tomcat的脚本文件。
/conf：存放Tomcat的各种全局配置文件，其中最重要的是server.xml。
/lib：存放Tomcat以及所有Web应用都可以访问的JAR文件。
/logs：存放Tomcat执行时产生的日志文件。
/work：存放JSP编译后产生的Class文件。
/webapps：Tomcat的Web应用目录，默认情况下把Web应用放在这个目录下。
```

<img src="https://dongchanglei.top/images/tomcatlog.png">

```
catalina.***.log
主要是记录Tomcat启动过程的信息，在这个文件可以看到启动的JVM参数以及操作系统等日志信息。

catalina.out
是Tomcat的标准输出（stdout）和标准错误（stderr），这是在Tomcat的启动脚本里指定的，如果没有修改的话stdout和stderr会重定向到这里。

localhost.**.log
主要记录Web应用在初始化过程中遇到的未处理的异常，会被Tomcat捕获而输出这个日志文件。

localhost_access_log.**.txt
存放访问Tomcat的请求日志，包括IP地址以及请求的路径、时间、请求协议以及状态码等信息。

manager.***.log/host-manager.***.log
存放Tomcat自带的Manager项目的日志信息。
```
```
javac -cp ./servlet-api.jar MyServlet.java
```
<img src="https://dongchanglei.top/images/MyServletJava.png">
<img src="https://dongchanglei.top/images/MyWebApp.png">

##分析Tomcat的设计思路
**Tomcat总体架构**
```
处理Socket连接，负责网络字节流与Request和Response对象的转化。
加载和管理Servlet，以及具体处理Request请求。
```

**因此Tomcat设计了两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情。连接器负责对外交流，容器负责内部处理。**

**下面我们就先聊聊连接器（Connector）**
```
做个铺垫：
Tomcat支持的I/O模型有：
NIO：非阻塞I/O，采用Java NIO类库实现。
NIO.2：异步I/O，采用JDK 7最新的NIO.2类库实现。
APR：采用Apache可移植运行库实现，是C/C++编写的本地库。
Tomcat 支持的应用层协议有：
HTTP/1.1：这是大部分Web应用采用的访问协议。
AJP：用于和Web服务器集成（如 Apache）。
HTTP/2：HTTP2.0大幅度的提升了Web性能。
```
Tomcat为了实现支持多种I/O模型和应用层协议，一个容器可能对接多个连接器，就好比一个房间有多个门；但是单独的连接器或者容器都不能对外提供服务，需要把它们组装起来才能工作，组装后这个整体叫作**Service组件**；
Tomcat内可能有多个Service，通过在Tomcat中配置多个Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用，但是Service本身没有做什么重要的事情，只是在连接器和容器外面多包了一层，把它们组装在一起；

**此时，我们可以得出一张图**

<img src="https://dongchanglei.top/images/tomcat01.png">

```
从图上你可以看到，最顶层是Server，这里的Server指的就是一个Tomcat实例。一个Server中有一个或者多个Service，一个Service中有多个连接器和一个容器。连接器与容器之间通过标准的ServletRequest和ServletResponse通信。
```
连接器对Servlet容器屏蔽了协议及I/O模型等的区别，在容器中获取到的都是一个标准的 ServletRequest和ServletResponse对象。

**连接器的功能进一步细化**
```
监听网络端口。
接受网络连接请求。
读取网络请求字节流。
根据具体应用层协议（HTTP/AJP）解析字节流，生成统一的Tomcat Request对象。
将Tomcat Request对象转成标准的ServletRequest。
调用Servlet容器，得到ServletResponse。
将ServletResponse转成Tomcat Response对象。
将Tomcat Response转成网络字节流。
将响应字节流写回给浏览器。
```

**如果让你设计连接器（Connector），你该如何设计，达到高内聚、低耦合的效果？？？**

```
简单阐述下这两个概念：
高内聚是指相关度比较高的功能要尽可能集中，不要分散。
低耦合是指两个相关的模块要尽可能减少依赖的部分和降低依赖的程度，不要让两个模块产生强依赖。
```

**好了，让我们看一看Tomcat是如何设计的？？**

```
有3个高内聚的功能：
网络通信。
应用层协议解析。
Tomcat Request/Response与ServletRequest/ServletResponse的转化。
```
因此Tomcat的设计者设计了3个组件来实现这3个功能，分别是**Endpoint**、**Processor**和**Adapter**。

**老规矩，看图说话**

<img src="https://dongchanglei.top/images/tomcat02.png">

```
ProtocolHandler 来处理网络连接和应用层协议，包含了Endpoint和Processor两个重要组件。

Endpoint是通信端点，即通信监听的接口，是具体的Socket接收和发送处理器，是对传输层的抽象，因此Endpoint是用来实现TCP/IP协议的。

Processor用来实现HTTP协议等其他应用层协议，Processor接收来自Endpoint的Socket，读取字节流解析成Tomcat Request和Response对象，并通过Adapter将其提交到容器处理，Processor是对应用层协议的抽象。
```

<img src="https://dongchanglei.top/images/ProtocolHandler.png">
<img src="https://dongchanglei.top/images/Endpoint.png">
<img src="https://dongchanglei.top/images/processor.png">


```
Adapter组件的作用就是连接器调用CoyoteAdapter的sevice方法，传入的是Tomcat Request对象，CoyoteAdapter负责将Tomcat Request转成ServletRequest，再调用容器的service方法。
```

**好了，连接器（Connector）就先到这，接下来我们看一下容器（Container）！！**

**容器的层次结构**

Tomcat设计了4种容器，分别是Engine、Host、Context和Wrapper。
先简单的看一下面的图，形象直观的看一下Tomcat的容器的层次结构：
<img src="https://dongchanglei.top/images/tomcat-contanier.png">

```
Context表示一个Web应用程序；
Wrapper表示一个Servlet，一个Web应用程序中可能会有多个Servlet；
Host代表的是一个虚拟主机，或者说一个站点，可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可以部署多个Web应用程序；
Engine表示引擎，用来管理多个虚拟站点;
Service最多只能有一个Engine。
```
下面我们再从server.xml配置文件对Tomcat容器进一步探讨：
<img src="https://dongchanglei.top/images/tomcat-contanier01.png">

你会发现这些容器具有父子关系，形成一个树形结构，Tomcat就是用组合模式来管理这些容器的。这些容器都实现了Container接口，看一下接口定义:
```java
public interface Container extends Lifecycle {
    public void setName(String name);
    public Container getParent();
    public void setParent(Container container);
    public void addChild(Container child);
    public void removeChild(Container child);
    public Container findChild(String name);
}
```
从接口定义上也进一步验证了这些容器具有父子关系；你可能还注意到Container接口扩展了 **Lifecycle**接口，它是用来统一管理Tomcat各组件的生命周期，在后面我会介绍它。

**在使用Tomcat之初，不知道你是否存在好奇，在配置文件一通配置，它一启动拼接好请求连接就能访问到我们定义的Servlet，它是怎么定位到我们要请求的Servlet？**

我先说一下答案吧，那就是Mapper组件。

```java
/**
 * Mapper, which implements the servlet API mapping rules (which are derived
 * from the HTTP rules).
 *
 * @author Remy Maucherat
 */
public final class Mapper {}
```
从接口定义上不难看出他就是servlet API mapping rules。
Mapper组件的功能就是将用户请求的URL定位到一个Servlet，它的工作原理是：Mapper组件里保存了Web应用的配置信息，其实就是容器组件与访问路径的映射关系，比如Host容器里配置的域名、Context容器里的Web应用路径，以及Wrapper容器里Servlet映射的路径，你可以想象这些配置信息就是一个多层次的Map。

**下面就总结一下Tomcat如何将一个URL定位到一个Servlet的过程：**
```
首先，根据协议和端口号选定Service和Engine。
然后，根据域名选定Host。
之后，根据URL路径找到Context组件。
最后，根据URL路径找到Wrapper（Servlet）。
```

看到这里，我想大家应该已经了解了什么是容器，以及Tomcat如何通过一层一层的父子容器找到某个Servlet来处理请求。需要注意的是，并不是说只有Servlet才会去处理请求，实际上这个查找路径上的父子容器都会对请求做一些处理。连接器中的Adapter会调用容器的Service方法来执行Servlet，最先拿到请求的是Engine容器，Engine容器对请求做一些处理后，会把请求传给自己子容器Host继续处理，依次类推，最后这个请求会传给Wrapper容器，Wrapper会调用最终的Servlet来处理。

**那么这个调用过程具体是怎么实现的呢？**
```
答案就是使用Pipeline-Valve管道。
```

Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理。
Valve表示一个处理点，比如权限认证和记录日志。

可以来看看Valve和Pipeline接口中的关键方法:
```java
public interface Valve {
  public Valve getNext();
  public void setNext(Valve valve);
  public void invoke(Request request, Response response)
}
```
由于Valve是一个处理点，因此invoke方法就是来处理请求的。注意到Valve中有getNext和 setNext方法，因此我们大概可以猜到有一个链表将Valve链起来了。
请大家继续看Pipeline 接口：
```java
public interface Pipeline extends Contained {
  public void addValve(Valve valve);
  public Valve getBasic();
  public void setBasic(Valve valve);
  public Valve getFirst();
}
```
没错，Pipeline中有addValve方法。Pipeline中维护了Valve链表，Valve可以插入到 Pipeline中，对请求做某些处理。我们还发现Pipeline中没有invoke方法，因为整个调用链的触发是Valve来完成的，Valve完成自己的处理后，调用getNext.invoke来触发下一个Valve调用。
每一个容器都有一个Pipeline对象，只要触发这个Pipeline的第一个Valve，这个容器里Pipeline中的Valve就都会被调用到。
**但是，不同容器的Pipeline是怎么链式触发的呢，比如Engine中Pipeline需要调用下层容器Host中的Pipeline?**

这是因为Pipeline中还有个getBasic方法。这个BasicValve处于Valve链表的末端，它是Pipeline中必不可少的一个Valve，负责调用下层容器的Pipeline里的第一个Valve。
```java
public class StandardPipeline extends LifecycleBase implements Pipeline {
    // ------------------------------ Instance Variables

    /**
     * The basic Valve (if any) associated with this Pipeline.
     */
    protected Valve basic = null;
    
    /**
     * The Container with which this Pipeline is associated.
     */
    protected Container container = null;
    
    /**
     * The first valve associated with this Pipeline.
     */
    protected Valve first = null;
}
```
我还是通过下面一张图来解释:
<img src="https://dongchanglei.top/images/pipeline.png">

整个调用过程由连接器中的Adapter触发的，它会调用 Engine 的第一个 Valve：
```java
/**
 * Implementation of a request processor which delegates the processing to a
 * Coyote processor.
 *
 * @author Craig R. McClanahan
 * @author Remy Maucherat
 */
public class CoyoteAdapter implements Adapter {

  @Override
    public void service(org.apache.coyote.Request req, org.apache.coyote.Response res)
            throws Exception {
            // Calling the container
 connector.getService().getContainer().getPipeline()
.getFirst().invoke(request, response);
        }
}
```

**Tomcat为了提高处理能力和并发度，把处理请求的工作放到线程池里来执行，那么Tomcat是如何扩展Java线程池的？？**

先看一下java原生的线程池核心类ThreadPoolExecutor的构造函数
```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler){}
```

```
每次提交任务时，如果线程数还没达到核心线程数corePoolSize，线程池就创建新线程来执行。
当线程数达到corePoolSize后，新增的任务就放到工作队列workQueue里，而线程池中的线程则努力地从workQueue里拉活来干，也就是调用poll方法来获取任务。
如果任务很多，并且workQueue是个有界队列，队列可能会满，此时线程池就会紧急创建新的临时线程来救场，如果总的线程数达到了最大线程数maximumPoolSize，则不能再创建新的临时线程了，转而执行拒绝策略handler，比如抛出异常或者由调用者线程来执行任务等。
如果高峰过去了，线程池比较闲了怎么办？临时线程使用poll（keepAliveTime, unit）方法从工作队列中拉活干，请注意poll方法设置了超时时间，如果超时了仍然两手空空没拉到活，表明它太闲了，这个线程会被销毁回收。
```

**Tomcat定制版的ThreadPoolExecutor**

```
Tomcat线程池对资源限制：
Tomcat有自己的定制版任务队列和线程工厂，并且可以限制任务队列的长度，它的最大长度是 maxQueueSize。
Tomcat对线程数也有限制，设置了核心线程数（minSpareThreads）和最大线程池数（maxThreads）。
Tomcat线程池还定制自己的任务处理流程：
1.前corePoolSize个任务时，来一个任务就创建一个新线程。
2.后面再来任务，就把任务添加到任务队列里让所有的线程去抢，如果队列满了就创建临时线程。
3.如果总线程数达到 maximumPoolSize，则继续尝试把任务添加到任务队列中去。
4.如果缓冲队列也满了，插入失败，执行拒绝策略。
```

```java

public class ThreadPoolExecutor extends java.util.concurrent.ThreadPoolExecutor {
  
  ...
  
  public void execute(Runnable command, long timeout, TimeUnit unit) {
      submittedCount.incrementAndGet();
      try {
          //调用Java原生线程池的execute去执行任务
          super.execute(command);
      } catch (RejectedExecutionException rx) {
         //如果总线程数达到maximumPoolSize，Java原生线程池执行拒绝策略
          if (super.getQueue() instanceof TaskQueue) {
              final TaskQueue queue = (TaskQueue)super.getQueue();
              try {
                  //继续尝试把任务放到任务队列中去
                  if (!queue.force(command, timeout, unit)) {
                      submittedCount.decrementAndGet();
                      //如果缓冲队列也满了，插入失败，执行拒绝策略。
                      throw new RejectedExecutionException("...");
                  }
              } 
          }
      }
}
```