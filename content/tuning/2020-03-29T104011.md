---
desc: 由 genpost (https://github.com/hidevopsio/genpost) 代码生成器生成
title: MySQL专题(一)
date: 2020-03-29T10:40:11+08:00
author: 董长磊
draft: false
tags:
- MySQL专题(一)
---

## MySQL

#### MySQL索引数据结构推导
[初学数据结构](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

**二叉树** 如果数据是**单边增长**的情况 那么出现的就是和链表一样的数据结构了,**树的高度**,大数据量相当于全量查询.

**红黑树** 在二叉树的基础上多了树平衡,也叫二叉平衡树,不像二叉树那样极端的情况会往一个方向发展,但是大数据量下**树的高度**还是问题.

**B树(B-Tree)** 在红黑树的基础上,**每个节点可以存放多个数据来减小树的高度**.

**B+树(B+Tree)** B树的变种,**非叶子节点是会重复的,需要在叶子上面存放数据,并且在叶子节点有单向递增引用**.

**MySQL的索引是排好序的数据结构,MySQL的索引用的就是B+树(B+Tree)数据结构,但是在叶子节点存在双向引用**

    MySQL默认的一个节点16K的大小,可以通过show global status like "Innodb_page_size" 看到该值是16384,每次IO读取16K大小的数据,以索引列bigInt类型为例,大小8字节,每一条数据还有一个指向下一层的指针6字节,16384/（8+6）=1170,一个节点就大约可以存1170条数据.

    以一个层高为3的树为例,叶子节点存放数据之后大小1KB,那么这个树可以存放 1170 *1170 *16 =21,902,400,大约2200万条数据.所以在这种千万级的表中通过主键索引查找一条数据,最多3次IO就可以找到一条数据.而很多时候树的根节点基本都是在内存中,所以多数时候只需要2次IO.

    叶子节点之间也有双向指针连接,提高区间范围性能,范围查找,头尾也有双向指针.

#### 主键索引

1. 叶子节点存储**整行数据**
2. 叶子节点之间**双向引用**
3. 非叶子节点只存储**索引（冗余）**不存储其他数据 

#### 辅助索引

1. 叶子节点存储**主键ID**
2. 叶子节点之间**双向引用**
3. 非叶子节点只存储**索引（冗余）**不存储其他数据 

#### 联合主键索引

1. 叶子节点存储**整行数据**
2. 叶子节点之间**双向引用**
3. 非叶子节点只存储**索引（冗余）**不存储其他数据 
4. 索引排序是**按照建索引的顺序进行排序**
5. 在查询的时候要符合**最左前缀法则**索引才会生效

#### 联合索引

1. 叶子节点存储**主键ID**
2. 叶子节点之间**双向引用**
3. 非叶子节点只存储**索引（冗余）**不存储其他数据 
4. 索引排序是**按照建索引的顺序进行排序**
5. 在查询的时候要符合**最左前缀法则**索引才会生效

#### MySQL分析工具Explain
```sql 
DROP TABLE IF EXISTS `actor`;
CREATE TABLE `actor` (
	`id` int(11) NOT NULL,
	`name` varchar(45) DEFAULT NULL,
	`update_time` datetime DEFAULT NULL,
	PRIMARY KEY (`id`)) ENGINE = InnoDB DEFAULT CHARSET = utf8;
	
INSERT INTO `actor` (`id`, `name`, `update_time`)
VALUES(1, 'a', '2017‐12‐2 2 15:27:18'), 
		(2, 'b', '2017‐12‐22 15:27:18'), 
		(3, 'c', '2017‐12‐22 15:27:18');
		
		
DROP TABLE IF EXISTS `film`;
CREATE TABLE `film` (
	`id` int(11) NOT NULL AUTO_INCREMENT,
	`name` varchar(10) DEFAULT NULL,
	PRIMARY KEY (`id`),
	KEY `idx_name` (`name`)) ENGINE = InnoDB DEFAULT CHARSET = utf8;
	
INSERT INTO `film` (`id`, `name`) 
VALUES (3,'film0'),(1,'film1'),(2,'film 2');


DROP TABLE IF EXISTS `film_actor`;
CREATE TABLE `film_actor` (
	`id` int(11) NOT NULL,
	`film_id` int(11) NOT NULL,
	`actor_id` int(11) NOT NULL,
	`remark` varchar(255) DEFAULT NULL,
	PRIMARY KEY (`id`),
	KEY `idx_film_actor_id` (`film_id`,
		`actor_id`)) ENGINE = InnoDB DEFAULT CHARSET = utf8;
		
INSERT INTO `film_actor` (`id`, `film_id`, `actor_id`) VALUES (1,1,1), (2,1,2),(3,2,1);
```

#### explain中的列
```sql 
explain select * from actor;
```

<img src="https://dongchanglei.top/images/explain.png" >

**1、id列**
id列的编号是select的序列号，有几个select就有几个id，并且id的顺序是按select出现顺序增长的；

**2、select_type列**
select_type表示对应行是简单还是复杂的查询；

1）simple：简单查询，查询不包含子查询和union
<img src="https://dongchanglei.top/images/select_type.png">

2）primary：复杂查询中最外层的 select
3）subquery：包含在 select 中的子查询（不在 from 子句中）
4）derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为 派生表（derived的英文含义）
用这个例子来了解 primary、subquery 和 derived 类型
```sql 
#关闭mysql5.7新特性对衍 生表的合并优化
set session optimizer_switch='derived_merge=off'; 

explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;

#还原默认配置
set session optimizer_switch='derived_merge=on'; 
```

<img src="https://dongchanglei.top/images/primary-subquery-derived.png">

5）union：在 union 中的第二个和随后的 select

```sql 
explain select 1 union all select 1;
```
<img src="https://dongchanglei.top/images/union.png">

**3、table列**
这一列表示 explain 的一行正在访问哪个表
当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查 询，于是先执行 id=N 的查询。 
当有 union 时，UNION RESULT 的 table 列的值为<union1,2>，1和2表示参与 union 的 select 行id。

**4、type列**
这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概 范围。

依次从最优到最差分别为：
**system > const > eq_ref > ref > range > index > ALL 一般来说，得保证查询达到range级别，最好达到ref**

NULL：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。
例如：在 索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表
```sql  
explain select min(id) from film;
```
<img src="https://dongchanglei.top/images/type-null.png">

const, system：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。
用于 primary key 或 unique key 的所有列与常数比较时，所以表最多 有一个匹配行，读取1次，速度比较快。
system是const的特例，表里只有一条元组匹配时为 system

```sql 
 #MYSQL5.7
 explain extended select * from (select * from film where id = 1) tmp;
 show warnings;
 
 #MYSQL8+
 explain select * from (select * from film where id = 1) tmp;
 show warnings;
```

<img src="https://dongchanglei.top/images/explain-extended.png">

<img src="https://dongchanglei.top/images/warnning.png">

eq_ref：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合 条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。

```sql 
 explain select * from film_actor left join film on film_actor.film_id = film.id;
```

<img src="https://dongchanglei.top/images/eq-ref.png">

ref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要 和某个值相比较，可能会找到多个符合条件的行。 

1) 简单 select 查询，name是普通索引（非唯一索引）
```sql 
 explain select * from film where name = 'film1';
```
<img src="https://dongchanglei.top/images/ref.png">

2) 关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor 的左边前缀film_id部分。
```sql 
 explain select film_id from film left join film_actor on film.id = film_actor.film_id;
```
<img src="https://dongchanglei.top/images/ref1.png">


